#version 450
#extension GL_GOOGLE_include_directive : require

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout (binding = 0) uniform Uniforms
{
  mat4 view_matrix;
  mat4 projection_matrix;
  vec4 camera_position;
  vec4 camera_direction;
  vec4 resolution;
  vec4 background_color;
  float time;
  uint object_count;
  float _padding[1];
}
ubo;

layout (binding = 1, rgba32f) uniform writeonly image2D output_color_depth;
layout (binding = 3, rgba32f) uniform writeonly image2D output_normal;

struct SDFObject
{
  vec4 position;
  vec4 color;
  vec4 dimensions;
  vec4 params;
};

layout (std430, binding = 2) buffer SDFObjects { SDFObject objects[]; }
sdf_objects;

#include "raymarch_core.glsl"

vec3
linear_to_srgb (vec3 linear)
{
  return pow (linear, vec3 (1.0 / 2.2));
}

void
main ()
{
  ivec2 pixel_coords = ivec2 (gl_GlobalInvocationID.xy);

  if (pixel_coords.x >= int (ubo.resolution.x)
      || pixel_coords.y >= int (ubo.resolution.y))
    {
      return;
    }

  vec2 uv = (vec2 (pixel_coords.x, ubo.resolution.y - pixel_coords.y)
             - ubo.resolution.xy * 0.5)
            / ubo.resolution.y;

  vec3 ro = ubo.camera_position.xyz;
  vec3 forward = normalize (ubo.camera_direction.xyz);
  vec3 right = normalize (cross (forward, vec3 (0.0, 1.0, 0.0)));
  vec3 up = cross (right, forward);

  float fov = 1.0;
  vec3 rd = normalize (forward + uv.x * right * fov + uv.y * up * fov);

  RaymarchResult result = raymarch (ro, rd, ubo.camera_position.xyz);

  imageStore (output_color_depth, pixel_coords, result.color);

  imageStore (output_normal, pixel_coords, result.normal_pos);
}
