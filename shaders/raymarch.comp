#version 450

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0) uniform Uniforms {
    mat4 view_matrix;
    mat4 projection_matrix;
    vec4 camera_position;
    vec4 camera_direction;
    vec2 resolution;
    float time;
} ubo;

layout(binding = 1, rgba8) uniform writeonly image2D output_image;

struct SDFObject {
    vec4 position;      // w = radius/scale
    vec4 rotation;      // quaternion
    vec4 dimensions;
    vec4 color;
    uint type;
    uint material_id;
    float smoothing;
    float padding;
};

layout(binding = 2) buffer SDFObjects {
    SDFObject objects[];
} sdf_objects;

// consts
const int MAX_STEPS = 128;
const float MAX_DIST = 100.0;
const float EPSILON = 0.001;

vec3 linear_to_srgb(vec3 linear) {
    return pow(linear, vec3(1.0 / 2.2));
}

// SDF primitives
float sdf_sphere(vec3 p, float r) {
    return length(p) - r;
}

float sdf_box(vec3 p, vec3 b) {
    vec3 q = abs(p) - b;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

float sdf_torus(vec3 p, vec2 t) {
    vec2 q = vec2(length(p.xz) - t.x, p.y);
    return length(q) - t.y;
}

float sdf_plane(vec3 p, vec3 n, float h) {
    return dot(p, n) + h;
}

// for blending
float smooth_min(float a, float b, float k) {
    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
    return mix(b, a, h) - k * h * (1.0 - h);
}

float scene_sdf(vec3 p, out vec4 color) {
    float min_dist = MAX_DIST;
    color = vec4(0.1, 0.1, 0.1, 1.0);
    
    // all SDF objects
    for (int i = 0; i < 256; i++) {
        SDFObject obj = sdf_objects.objects[i];
        
        // invalid objects
        if (obj.type == 0 && i > 0) break;
        
        vec3 local_p = p - obj.position.xyz;
        float dist = MAX_DIST;
        
        // Evaluate SDF based on type
        switch(obj.type) {
            case 0: // Sphere
                dist = sdf_sphere(local_p, obj.position.w);
                break;
            case 1: // Box
                dist = sdf_box(local_p, obj.dimensions.xyz);
                break;
            case 2: // Torus
                dist = sdf_torus(local_p, obj.dimensions.xy);
                break;
            case 3: // Plane
                dist = sdf_plane(local_p, obj.dimensions.xyz, obj.dimensions.w);
                break;
        }
        
        if (dist < min_dist) {
            min_dist = dist;
            color = obj.color;
        }
    }
    
    return min_dist;
}

vec3 calculate_normal(vec3 p) {
    vec4 dummy_color;
    vec2 e = vec2(EPSILON, 0.0);
    return normalize(vec3(
        scene_sdf(p + e.xyy, dummy_color) - scene_sdf(p - e.xyy, dummy_color),
        scene_sdf(p + e.yxy, dummy_color) - scene_sdf(p - e.yxy, dummy_color),
        scene_sdf(p + e.yyx, dummy_color) - scene_sdf(p - e.yyx, dummy_color)
    ));
}

vec3 apply_lighting(vec3 p, vec3 normal, vec3 color) {
    vec3 light_pos = vec3(5.0, 10.0, 5.0);
    vec3 light_dir = normalize(light_pos - p);
    
    float diffuse = max(dot(normal, light_dir), 0.0);
    
    float ambient = 0.2;
    
    // Specular
    vec3 view_dir = normalize(ubo.camera_position.xyz - p);
    vec3 reflect_dir = reflect(-light_dir, normal);
    float specular = pow(max(dot(view_dir, reflect_dir), 0.0), 32.0);
    
    return color * (ambient + 0.6 * diffuse) + vec3(0.3) * specular;
}

vec4 raymarch(vec3 ro, vec3 rd) {
    float depth = 0.0;
    vec4 color = vec4(0.0);
    
    for (int i = 0; i < MAX_STEPS; i++) {
        vec3 p = ro + rd * depth;
        float dist = scene_sdf(p, color);
        
        if (dist < EPSILON) {
            // Hit
            vec3 normal = calculate_normal(p);
            vec3 lit_color = apply_lighting(p, normal, color.rgb);
            return vec4(lit_color, 1.0);
        }
        
        depth += dist;
        
        if (depth >= MAX_DIST) {
            break;
        }
    }
    
    // Bg gradient
    float t = rd.y * 0.5 + 0.5;
    vec3 bg = mix(vec3(0.06, 0.06, 0.06), vec3(0.1, 0.1, 0.1), t);
    return vec4(bg, 1.0);
}

void main() {
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    
    if (pixel_coords.x >= int(ubo.resolution.x) || pixel_coords.y >= int(ubo.resolution.y)) {
        return;
    }
    
    // Ray direction
    vec2 uv = (vec2(pixel_coords.x, ubo.resolution.y - pixel_coords.y) - ubo.resolution * 0.5) / ubo.resolution.y;
    
    // Camera
    vec3 ro = ubo.camera_position.xyz;
    vec3 forward = normalize(ubo.camera_direction.xyz);
    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));
    vec3 up = cross(right, forward);
    
    // Ray dir by FOV
    float fov = 1.0;
    vec3 rd = normalize(forward + uv.x * right * fov + uv.y * up * fov);
    
    vec4 color = raymarch(ro, rd);
    
    imageStore(output_image, pixel_coords, color);
}
