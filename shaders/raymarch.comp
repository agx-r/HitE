#version 450
#extension GL_GOOGLE_include_directive : require

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout (binding = 0) uniform Uniforms
{
  mat4 view_matrix;
  mat4 projection_matrix;
  vec4 camera_position;
  vec4 camera_direction;
  vec4 resolution;
  float time;
  uint object_count;
  float _padding[2];
}
ubo;

layout (binding = 1, rgba8) uniform writeonly image2D output_image;

struct SDFObject
{
  vec4 position;
  vec4 color;
  vec4 dimensions;
  vec4 params;
};

layout (std430, binding = 2) buffer SDFObjects { SDFObject objects[]; }
sdf_objects;

// Include all modules
#include "raymarch_core.glsl"

vec3 linear_to_srgb(vec3 linear) {
  return pow(linear, vec3(1.0 / 2.2));
}

void main() {
  ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

  if (pixel_coords.x >= int(ubo.resolution.x) || pixel_coords.y >= int(ubo.resolution.y)) {
    return;
  }

  // Calculate UV coordinates
  vec2 uv = (vec2(pixel_coords.x, ubo.resolution.y - pixel_coords.y)
             - ubo.resolution.xy * 0.5) / ubo.resolution.y;

  // Camera setup
  vec3 ro = ubo.camera_position.xyz;
  vec3 forward = normalize(ubo.camera_direction.xyz);
  vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));
  vec3 up = cross(right, forward);

  // Ray direction
  float fov = 1.0;
  vec3 rd = normalize(forward + uv.x * right * fov + uv.y * up * fov);

  // Raymarch
  vec4 color = raymarch(ro, rd, ubo.camera_position.xyz);
  
  // Convert to sRGB and write
  color.rgb = linear_to_srgb(color.rgb);
  imageStore(output_image, pixel_coords, color);
}
