#version 450
#extension GL_GOOGLE_include_directive : require

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout (binding = 0) uniform Uniforms
{
  mat4 view_matrix;
  mat4 projection_matrix;
  vec4 camera_position;
  vec4 camera_direction;
  vec4 resolution;
  float time;
  uint object_count;
  float _padding[2];
}
ubo;

layout (binding = 1, rgba32f) uniform writeonly image2D output_color_depth;
layout (binding = 3, rgba32f) uniform writeonly image2D output_normal;

struct SDFObject
{
  vec4 position;
  vec4 color;
  vec4 dimensions;
  vec4 params;
};

layout (std430, binding = 2) buffer SDFObjects { SDFObject objects[]; }
sdf_objects;

// Include all modules
#include "raymarch_core.glsl"

vec3 linear_to_srgb(vec3 linear) {
  return pow(linear, vec3(1.0 / 2.2));
}

void main() {
  ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

  if (pixel_coords.x >= int(ubo.resolution.x) || pixel_coords.y >= int(ubo.resolution.y)) {
    return;
  }

  // Calculate UV coordinates
  vec2 uv = (vec2(pixel_coords.x, ubo.resolution.y - pixel_coords.y)
             - ubo.resolution.xy * 0.5) / ubo.resolution.y;

  // Camera setup
  vec3 ro = ubo.camera_position.xyz;
  vec3 forward = normalize(ubo.camera_direction.xyz);
  vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));
  vec3 up = cross(right, forward);

  // Ray direction
  float fov = 1.0;
  vec3 rd = normalize(forward + uv.x * right * fov + uv.y * up * fov);

  // Raymarch
  RaymarchResult result = raymarch(ro, rd, ubo.camera_position.xyz);
  
  // Write color and depth
  imageStore(output_color_depth, pixel_coords, result.color);
  
  // Write normal (already in 0..1 range)
  imageStore(output_normal, pixel_coords, result.normal_pos);
}
