#version 450
#extension GL_GOOGLE_include_directive : require

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout (binding = 0) uniform LightingUniforms
{
  vec4 sun_direction;
  vec4 sun_color;
  vec4 camera_position;
  vec4 camera_direction;
  vec4 resolution;
  vec4 background_color;
  float ambient_strength;
  float diffuse_strength;
  float shadow_bias;
  float shadow_softness;
  uint shadow_steps;
  uint object_count;
}
lighting_ubo;

layout (binding = 1, rgba32f) uniform readonly image2D input_color_depth;
layout (binding = 2, rgba32f) uniform readonly image2D input_normal;

layout (binding = 4, rgba8) uniform writeonly image2D output_image;

struct SDFObject
{
  vec4 position;
  vec4 color;
  vec4 dimensions;
  vec4 params;
};

layout (std430, binding = 5) buffer SDFObjects { SDFObject objects[]; }
sdf_objects;

#include "shapes/registry.glsl"

const int MAX_SHADOW_STEPS = 64;
const float MAX_SHADOW_DIST = 100.0;
const float SHADOW_EPSILON = 0.001;

float
scene_sdf_shadow (vec3 p)
{
  float min_dist = MAX_SHADOW_DIST;

  uint count = min (lighting_ubo.object_count, 256u);
  for (uint i = 0u; i < count; i++)
    {
      SDFObject obj = sdf_objects.objects[i];

      if (obj.dimensions.w < 0.5)
        {
          continue;
        }
      vec3 local_p = p - obj.position.xyz;

      float dist
          = eval_shape (local_p, obj.position, obj.dimensions, obj.params);

      if (dist < min_dist)
        {
          min_dist = dist;
        }
    }

  return min_dist;
}

float
shadow_raymarch (vec3 p, vec3 light_dir)
{

  float t = lighting_ubo.shadow_bias;
  float shadow = 1.0;
  float min_dist_to_obstacle = MAX_SHADOW_DIST;

  int steps = int (lighting_ubo.shadow_steps);
  if (steps > MAX_SHADOW_STEPS)
    steps = MAX_SHADOW_STEPS;

  for (int i = 0; i < steps; i++)
    {
      vec3 pos = p + light_dir * t;
      float dist = scene_sdf_shadow (pos);

      if (dist < SHADOW_EPSILON)
        {

          shadow = 0.0;
          break;
        }

      min_dist_to_obstacle = min (min_dist_to_obstacle, dist);

      t += max (dist, 0.01);
      if (t >= MAX_SHADOW_DIST)
        {

          break;
        }
    }

  if (shadow > 0.0 && min_dist_to_obstacle < MAX_SHADOW_DIST)
    {

      float shadow_amount = clamp (
          min_dist_to_obstacle / lighting_ubo.shadow_softness, 0.0, 1.0);

      shadow_amount = pow (shadow_amount, 0.3);
      shadow = shadow_amount;
    }

  return shadow;
}

vec3
linear_to_srgb (vec3 linear)
{
  return pow (linear, vec3 (1.0 / 2.2));
}

float
hash (vec2 p)
{
  return fract (sin (dot (p, vec2 (127.1, 311.7))) * 43758.5453);
}

float
hash3 (vec3 p)
{
  p = vec3 (dot (p, vec3 (127.1, 311.7, 74.7)),
            dot (p, vec3 (269.5, 183.3, 246.1)),
            dot (p, vec3 (113.5, 271.9, 124.6)));
  return fract (sin (p.x) * 43758.5453 + sin (p.y) * 43758.5453
                + sin (p.z) * 43758.5453);
}

float
noise3 (vec3 p)
{
  vec3 i = floor (p);
  vec3 f = fract (p);
  f = f * f * (3.0 - 2.0 * f);

  float n000 = hash3 (i + vec3 (0.0, 0.0, 0.0));
  float n100 = hash3 (i + vec3 (1.0, 0.0, 0.0));
  float n010 = hash3 (i + vec3 (0.0, 1.0, 0.0));
  float n110 = hash3 (i + vec3 (1.0, 1.0, 0.0));
  float n001 = hash3 (i + vec3 (0.0, 0.0, 1.0));
  float n101 = hash3 (i + vec3 (1.0, 0.0, 1.0));
  float n011 = hash3 (i + vec3 (0.0, 1.0, 1.0));
  float n111 = hash3 (i + vec3 (1.0, 1.0, 1.0));

  return mix (mix (mix (n000, n100, f.x), mix (n010, n110, f.x), f.y),
              mix (mix (n001, n101, f.x), mix (n011, n111, f.x), f.y), f.z);
}

void
main ()
{
  ivec2 pixel_coords = ivec2 (gl_GlobalInvocationID.xy);

  if (pixel_coords.x >= int (lighting_ubo.resolution.x)
      || pixel_coords.y >= int (lighting_ubo.resolution.y))
    {
      return;
    }

  vec4 color_depth = imageLoad (input_color_depth, pixel_coords);
  vec3 surface_color = color_depth.rgb;
  float depth = color_depth.a;

  vec4 normal_data = imageLoad (input_normal, pixel_coords);
  vec3 normal = normalize (normal_data.xyz * 2.0 - 1.0);
  bool hit = normal_data.a > 0.5;

  vec3 final_color = surface_color;

  if (hit && depth > 0.0 && depth < 100.0)
    {

      vec2 uv
          = (vec2 (pixel_coords.x, lighting_ubo.resolution.y - pixel_coords.y)
             - lighting_ubo.resolution.xy * 0.5)
            / lighting_ubo.resolution.y;

      vec3 forward = normalize (lighting_ubo.camera_direction.xyz);
      vec3 right = normalize (cross (forward, vec3 (0.0, 1.0, 0.0)));
      vec3 up = cross (right, forward);

      float fov = 1.0;
      vec3 view_dir
          = normalize (forward + uv.x * right * fov + uv.y * up * fov);

      vec3 camera_pos = lighting_ubo.camera_position.xyz;
      vec3 world_pos = camera_pos + view_dir * depth;

      vec3 sun_dir = normalize (lighting_ubo.sun_direction.xyz);

      float NdotL = max (dot (normal, sun_dir), 0.0);

      float shadow = shadow_raymarch (world_pos, sun_dir);

      vec3 ambient = surface_color * lighting_ubo.ambient_strength;

      vec3 sun_light = lighting_ubo.sun_color.rgb;
      float light_factor = lighting_ubo.diffuse_strength * NdotL * shadow;
      vec3 diffuse = surface_color * light_factor;
      diffuse = diffuse * sun_light;

      float shadow_factor = max (shadow, 0.2);
      vec3 lit_color = ambient * shadow_factor + diffuse;

      float shadow_blend = 1.0 - shadow;
      final_color = mix (lit_color, lighting_ubo.background_color.rgb,
                         shadow_blend * 0.6);

      final_color = min (final_color, vec3 (1.0));

      float luminance = dot (final_color, vec3 (0.299, 0.587, 0.114));
      bool is_white_surface = luminance > 0.7;

      if (is_white_surface)
        {

          float depth_factor = 1.0 - smoothstep (0.0, 20.0, depth) * 0.15;
          final_color *= depth_factor;
        }

      const float NOISE_DISTANCE = 10.0;
      if (depth < NOISE_DISTANCE)
        {

          float noise_strength = (1.0 - depth / NOISE_DISTANCE) * 0.02;

          noise_strength *= mix (0.2, 1.0, shadow);

          vec3 noise_pos = world_pos * 10.0;
          float n = noise3 (noise_pos);

          vec3 noise_offset = vec3 ((n - 0.5) * noise_strength);
          final_color += noise_offset;
        }
    }
  else
    {

      final_color = lighting_ubo.background_color.rgb;
    }

  const float RAYMARCH_MAX_DIST = 100.0;
  float fade_start = RAYMARCH_MAX_DIST * 0.7;
  float fade_t = 0.0;
  if (depth >= fade_start)
    {
      fade_t = smoothstep (
          0.0, 1.0, (depth - fade_start) / (RAYMARCH_MAX_DIST - fade_start));
    }
  final_color = mix (final_color, lighting_ubo.background_color.rgb, fade_t);

  final_color = linear_to_srgb (final_color);
  imageStore (output_image, pixel_coords, vec4 (final_color, 1.0));
}
