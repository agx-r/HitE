#version 450
#extension GL_GOOGLE_include_directive : require

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout (binding = 0) uniform LightingUniforms
{
  vec4 sun_direction;      // xyz = direction, w = unused
  vec4 sun_color;          // xyz = color, w = unused
  vec4 camera_position;    // xyz = position, w = unused
  vec4 camera_direction;  // xyz = direction, w = unused
  vec4 resolution;         // xy = resolution, zw = unused
  float ambient_strength;
  float diffuse_strength;
  float shadow_bias;
  float shadow_softness;
  uint shadow_steps;
  uint object_count;
  float _padding[1];
}
lighting_ubo;

layout (binding = 1, rgba32f) uniform readonly image2D input_color_depth;
layout (binding = 2, rgba32f) uniform readonly image2D input_normal;
// Note: binding 3 is unused but kept for compatibility
layout (binding = 4, rgba8) uniform writeonly image2D output_image;

// SDF objects for shadow raymarching
struct SDFObject
{
  vec4 position;
  vec4 color;
  vec4 dimensions;
  vec4 params;
};

layout (std430, binding = 5) buffer SDFObjects { SDFObject objects[]; }
sdf_objects;

// Include shape evaluation
#include "shapes/registry.glsl"

// Raymarching constants for shadows
const int MAX_SHADOW_STEPS = 64;
const float MAX_SHADOW_DIST = 100.0;
const float SHADOW_EPSILON = 0.001;

// Scene evaluation for shadow raymarching
float scene_sdf_shadow(vec3 p) {
  float min_dist = MAX_SHADOW_DIST;

  uint count = min(lighting_ubo.object_count, 256u);
  for (uint i = 0u; i < count; i++) {
    SDFObject obj = sdf_objects.objects[i];
    // Skip empty slots - check if dimensions are zero (type is stored in dimensions.w)
    // If type is 0 or dimensions are all zero, it's likely an empty slot
    if (obj.dimensions.w < 0.5) { // Type 0 usually means unused
      continue;
    }
    vec3 local_p = p - obj.position.xyz;
    
    float dist = eval_shape(local_p, obj.position, obj.dimensions, obj.params);
    
    if (dist < min_dist) {
      min_dist = dist;
    }
  }

  return min_dist;
}

// Shadow raymarch from hit point to light
float shadow_raymarch(vec3 p, vec3 light_dir) {
  // Start raymarch from hit point with small bias to avoid self-intersection
  float t = lighting_ubo.shadow_bias;
  float shadow = 1.0;
  float min_dist_to_obstacle = MAX_SHADOW_DIST;
  
  int steps = int(lighting_ubo.shadow_steps);
  if (steps > MAX_SHADOW_STEPS) steps = MAX_SHADOW_STEPS;
  
  for (int i = 0; i < steps; i++) {
    vec3 pos = p + light_dir * t;
    float dist = scene_sdf_shadow(pos);
    
    if (dist < SHADOW_EPSILON) {
      // In shadow - hit an object
      shadow = 0.0;
      break;
    }
    
    // Track closest obstacle for soft shadows
    min_dist_to_obstacle = min(min_dist_to_obstacle, dist);
    
    // Move forward along light direction
    t += max(dist, 0.01); // Ensure we always move forward
    if (t >= MAX_SHADOW_DIST) {
      // Reached light, no hard shadow
      break;
    }
  }
  
  // Apply soft shadows based on closest obstacle found
  // Only apply soft shadows if we didn't hit anything (no hard shadow)
  if (shadow > 0.0 && min_dist_to_obstacle < MAX_SHADOW_DIST) {
    // Soft shadow: the closer the obstacle, the darker it gets
    // shadow_softness controls how far the penumbra extends
    // Make shadows darker and more pronounced
    float shadow_amount = clamp(min_dist_to_obstacle / lighting_ubo.shadow_softness, 0.0, 1.0);
    // Apply power curve to make shadows darker and more distinct
    // Use lower power for sharper, darker shadows
    shadow_amount = pow(shadow_amount, 0.3); // Makes shadows much darker and sharper
    shadow = shadow_amount; // 1.0 = no shadow (obstacle far), 0.0 = full shadow (obstacle close)
  }
  
  return shadow;
}

// Convert linear to sRGB
vec3 linear_to_srgb(vec3 linear) {
  return pow(linear, vec3(1.0 / 2.2));
}

void main() {
  ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

  if (pixel_coords.x >= int(lighting_ubo.resolution.x) || pixel_coords.y >= int(lighting_ubo.resolution.y)) {
    return;
  }

  // Read color and depth
  vec4 color_depth = imageLoad(input_color_depth, pixel_coords);
  vec3 surface_color = color_depth.rgb;
  float depth = color_depth.a;
  
  // Read normal (convert from 0..1 back to -1..1)
  vec4 normal_data = imageLoad(input_normal, pixel_coords);
  vec3 normal = normalize(normal_data.xyz * 2.0 - 1.0);
  bool hit = normal_data.a > 0.5;
  
  vec3 final_color = surface_color;
  
  // Apply lighting only if we hit something
  if (hit && depth > 0.0 && depth < 100.0) {
    // Reconstruct world position from depth
    // Use the SAME calculation as in raymarch.comp to ensure consistency
    vec2 uv = (vec2(pixel_coords.x, lighting_ubo.resolution.y - pixel_coords.y)
               - lighting_ubo.resolution.xy * 0.5) / lighting_ubo.resolution.y;
    
    // Reconstruct ray direction (same as raymarch.comp)
    vec3 forward = normalize(lighting_ubo.camera_direction.xyz);
    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));
    vec3 up = cross(right, forward);
    
    float fov = 1.0;
    vec3 view_dir = normalize(forward + uv.x * right * fov + uv.y * up * fov);
    
    // Calculate world position
    vec3 camera_pos = lighting_ubo.camera_position.xyz;
    vec3 world_pos = camera_pos + view_dir * depth;
    
    // Sun direction
    vec3 sun_dir = normalize(lighting_ubo.sun_direction.xyz);
    
    // Calculate lighting
    float NdotL = max(dot(normal, sun_dir), 0.0);
    
    // Calculate shadow
    float shadow = shadow_raymarch(world_pos, sun_dir);
    
    // Combine lighting
    // Ambient - base color dimmed (environmental light)
    vec3 ambient = surface_color * lighting_ubo.ambient_strength;
    
    // Diffuse - direct sunlight with color tint
    // When shadow = 0, diffuse should be 0 (fully in shadow)
    // When shadow = 1 and NdotL = 1, diffuse should be full strength
    vec3 sun_light = lighting_ubo.sun_color.rgb;
    float light_factor = lighting_ubo.diffuse_strength * NdotL * shadow;
    vec3 diffuse = surface_color * light_factor;
    diffuse = diffuse * sun_light; // Apply sun color tint
    
    // Final color is ambient (always present) + diffuse (only when lit)
    // Make shadows more pronounced by reducing ambient in shadowed areas
    float shadow_factor = max(shadow, 0.2); // Allow darker shadows but keep minimum visibility
    final_color = ambient * shadow_factor + diffuse;
    
    // Clamp to prevent overbrightening
    final_color = min(final_color, vec3(1.0));
  } else {
    // Background - keep original color
    final_color = surface_color;
  }
  
  // Convert to sRGB and write
  final_color = linear_to_srgb(final_color);
  imageStore(output_image, pixel_coords, vec4(final_color, 1.0));
}
