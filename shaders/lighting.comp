#version 450
#extension GL_GOOGLE_include_directive : require

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#include "common/scene_constants.glsl"

const float MAX_SHADOW_DISTANCE = SCENE_MAX_DISTANCE;
const float SHADOW_EPSILON = SCENE_SHADOW_EPSILON;
const int MAX_SHADOW_STEPS = SCENE_MAX_SHADOW_STEPS;

const float RAYMARCH_MAX_DISTANCE = SCENE_MAX_DISTANCE;
const float FADE_START_FACTOR = SCENE_FADE_START_FACTOR;
const float FADE_END_FACTOR = SCENE_FADE_END_FACTOR;

const float NOISE_MAX_DISTANCE = SCENE_NOISE_MAX_DISTANCE;
const float NOISE_MAX_STRENGTH = SCENE_NOISE_MAX_STRENGTH;
const float NOISE_SHADOW_MIN_BLEND = SCENE_NOISE_SHADOW_MIN_BLEND;
const float NOISE_SHADOW_MAX_BLEND = SCENE_NOISE_SHADOW_MAX_BLEND;
const float NOISE_SCALE = SCENE_NOISE_SCALE;

const float NEAR_LIGHT_DISTANCE = SCENE_NEAR_LIGHT_DISTANCE;
const float NEAR_LIGHT_STRENGTH = SCENE_NEAR_LIGHT_STRENGTH;
const float NEAR_LIGHT_POWER = SCENE_NEAR_LIGHT_POWER;

const float WHITE_SURFACE_LUMINANCE = SCENE_WHITE_SURFACE_LUMINANCE;
const float WHITE_SURFACE_DEPTH_MAX = SCENE_WHITE_SURFACE_DEPTH_MAX;
const float WHITE_SURFACE_DEPTH_REDUCE = SCENE_WHITE_SURFACE_DEPTH_REDUCE;

const float SHADOW_MIN_HARD = SCENE_SHADOW_MIN_HARD;
const float SHADOW_SOFT_BLEND = SCENE_SHADOW_SOFT_BLEND;
const float SHADOW_SOFT_POWER = SCENE_SHADOW_SOFT_POWER;

const float FOV_ASPECT_CORRECTION = SCENE_FOV_ASPECT_CORRECTION;
const float DEPTH_VALID_MIN = SCENE_DEPTH_VALID_MIN;
const float DEPTH_VALID_MAX = SCENE_MAX_DISTANCE;

const float NORMAL_UNPACK_SCALE = SCENE_NORMAL_UNPACK_SCALE;
const float NORMAL_UNPACK_BIAS = SCENE_NORMAL_UNPACK_BIAS;
const float HIT_FLAG_THRESHOLD = SCENE_HIT_FLAG_THRESHOLD;

const vec3 LUMINANCE_WEIGHTS = SCENE_LUMINANCE_WEIGHTS;
const float SRGB_GAMMA = SCENE_SRGB_GAMMA;

layout (binding = 0) uniform LightingUniforms
{
  vec4 sun_direction;
  vec4 sun_color;
  vec4 camera_position;
  vec4 camera_direction;
  vec4 resolution;
  vec4 background_color;
  float time;
  float ambient_strength;
  float diffuse_strength;
  float shadow_bias;
  float shadow_softness;
  uint shadow_steps;
  uint object_count;
}
lighting_ubo;

layout (binding = 1, rgba32f) uniform readonly image2D input_color_depth;
layout (binding = 2, rgba32f) uniform readonly image2D input_normal;
layout (binding = 4, rgba8) uniform writeonly image2D output_image;

struct SDFObject
{
  vec4 position;
  vec4 color;
  vec4 dimensions;
  vec4 params;
};

layout (std430, binding = 5) buffer SDFObjects { SDFObject objects[]; }
sdf_objects;

#include "shapes/registry.glsl"

float
scene_sdf_shadow (vec3 p)
{
  float min_dist = MAX_SHADOW_DISTANCE;
  uint count = min (lighting_ubo.object_count, 256u);
  for (uint i = 0u; i < count; i++)
    {
      SDFObject obj = sdf_objects.objects[i];
      if (obj.dimensions.w < HIT_FLAG_THRESHOLD)
        continue;

      vec3 local_p = p - obj.position.xyz;
      vec3 dynamic_color;
      bool has_dynamic_color;
      float dist
          = eval_shape (local_p, obj.position, obj.dimensions, obj.params,
                        lighting_ubo.time, dynamic_color, has_dynamic_color);
      min_dist = min (min_dist, dist);
    }
  return min_dist;
}

float
shadow_raymarch (vec3 p, vec3 light_dir)
{
  float t = lighting_ubo.shadow_bias;
  float shadow = 1.0;
  float min_dist_to_obstacle = MAX_SHADOW_DISTANCE;

  int steps = int (lighting_ubo.shadow_steps);
  steps = min (steps, MAX_SHADOW_STEPS);

  for (int i = 0; i < steps; i++)
    {
      vec3 pos = p + light_dir * t;
      float dist = scene_sdf_shadow (pos);

      if (dist < SHADOW_EPSILON)
        {
          shadow = 0.0;
          break;
        }

      min_dist_to_obstacle = min (min_dist_to_obstacle, dist);
      t += max (dist, 0.01);
      if (t >= MAX_SHADOW_DISTANCE)
        break;
    }

  if (shadow > 0.0 && min_dist_to_obstacle < MAX_SHADOW_DISTANCE)
    {
      float softness = clamp (
          min_dist_to_obstacle / lighting_ubo.shadow_softness, 0.0, 1.0);
      shadow = pow (softness, SHADOW_SOFT_POWER);
    }

  return shadow;
}

vec3
linear_to_srgb (vec3 linear)
{
  return pow (linear, vec3 (SRGB_GAMMA));
}

float
hash (vec2 p)
{
  return fract (sin (dot (p, vec2 (127.1, 311.7))) * 43758.5453);
}

float
hash3 (vec3 p)
{
  p = vec3 (dot (p, vec3 (127.1, 311.7, 74.7)),
            dot (p, vec3 (269.5, 183.3, 246.1)),
            dot (p, vec3 (113.5, 271.9, 124.6)));
  return fract (sin (p.x) * 43758.5453 + sin (p.y) * 43758.5453
                + sin (p.z) * 43758.5453);
}

float
noise3 (vec3 p)
{
  vec3 i = floor (p);
  vec3 f = fract (p);
  f = f * f * (3.0 - 2.0 * f);

  float n000 = hash3 (i + vec3 (0.0, 0.0, 0.0));
  float n100 = hash3 (i + vec3 (1.0, 0.0, 0.0));
  float n010 = hash3 (i + vec3 (0.0, 1.0, 0.0));
  float n110 = hash3 (i + vec3 (1.0, 1.0, 0.0));
  float n001 = hash3 (i + vec3 (0.0, 0.0, 1.0));
  float n101 = hash3 (i + vec3 (1.0, 0.0, 1.0));
  float n011 = hash3 (i + vec3 (0.0, 1.0, 1.0));
  float n111 = hash3 (i + vec3 (1.0, 1.0, 1.0));

  return mix (mix (mix (n000, n100, f.x), mix (n010, n110, f.x), f.y),
              mix (mix (n001, n101, f.x), mix (n011, n111, f.x), f.y), f.z);
}

void
main ()
{
  ivec2 pixel_coords = ivec2 (gl_GlobalInvocationID.xy);
  if (pixel_coords.x >= int (lighting_ubo.resolution.x)
      || pixel_coords.y >= int (lighting_ubo.resolution.y))
    {
      return;
    }

  vec4 color_depth = imageLoad (input_color_depth, pixel_coords);
  vec3 surface_color = color_depth.rgb;
  float depth = color_depth.a;

  vec4 normal_data = imageLoad (input_normal, pixel_coords);
  vec3 normal
      = normalize (normal_data.xyz * NORMAL_UNPACK_SCALE - NORMAL_UNPACK_BIAS);
  bool hit = normal_data.a > HIT_FLAG_THRESHOLD;

  vec3 final_color = surface_color;

  if (hit && depth > DEPTH_VALID_MIN && depth < DEPTH_VALID_MAX)
    {
      vec2 uv
          = (vec2 (pixel_coords.x, lighting_ubo.resolution.y - pixel_coords.y)
             - lighting_ubo.resolution.xy * 0.5)
            / lighting_ubo.resolution.y;

      vec3 forward = normalize (lighting_ubo.camera_direction.xyz);
      vec3 right = normalize (cross (forward, vec3 (0.0, 1.0, 0.0)));
      vec3 up = cross (right, forward);

      vec3 view_dir = normalize (forward + uv.x * right * FOV_ASPECT_CORRECTION
                                 + uv.y * up * FOV_ASPECT_CORRECTION);
      vec3 camera_pos = lighting_ubo.camera_position.xyz;
      vec3 world_pos = camera_pos + view_dir * depth;

      vec3 sun_dir = normalize (lighting_ubo.sun_direction.xyz);
      float NdotL = max (dot (normal, sun_dir), 0.0);
      float shadow = shadow_raymarch (world_pos, sun_dir);

      vec3 ambient = surface_color * lighting_ubo.ambient_strength;
      vec3 sun_light = lighting_ubo.sun_color.rgb;
      float light_factor = lighting_ubo.diffuse_strength * NdotL * shadow;
      vec3 diffuse = surface_color * light_factor * sun_light;

      float shadow_factor = max (shadow, SHADOW_MIN_HARD);
      vec3 lit_color = ambient * shadow_factor + diffuse;

      float shadow_blend = 1.0 - shadow;
      vec3 shadow_color = vec3 (0.0);
      final_color
          = mix (lit_color, shadow_color, shadow_blend * SHADOW_SOFT_BLEND);
      final_color = min (final_color, vec3 (1.0));

      float near_factor = 1.0 - clamp (depth / NEAR_LIGHT_DISTANCE, 0.0, 1.0);
      near_factor = pow (near_factor, NEAR_LIGHT_POWER);
      vec3 near_light = surface_color * near_factor * NEAR_LIGHT_STRENGTH;
      final_color += near_light;

      float luminance = dot (final_color, LUMINANCE_WEIGHTS);
      bool is_white_surface = luminance > WHITE_SURFACE_LUMINANCE;

      if (is_white_surface)
        {
          float depth_factor
              = 1.0
                - smoothstep (0.0, WHITE_SURFACE_DEPTH_MAX, depth)
                      * WHITE_SURFACE_DEPTH_REDUCE;
          final_color *= depth_factor;
        }

      if (depth < NOISE_MAX_DISTANCE)
        {
          float noise_strength
              = (1.0 - depth / NOISE_MAX_DISTANCE) * NOISE_MAX_STRENGTH;
          noise_strength
              *= mix (NOISE_SHADOW_MIN_BLEND, NOISE_SHADOW_MAX_BLEND, shadow);

          vec3 noise_pos = world_pos * NOISE_SCALE;
          float n = noise3 (noise_pos);
          vec3 noise_offset = vec3 ((n - 0.5) * noise_strength);
          final_color += noise_offset;
        }
    }
  else
    {
      final_color = lighting_ubo.background_color.rgb;
    }

  float fade_start = RAYMARCH_MAX_DISTANCE * FADE_START_FACTOR;
  float fade_t
      = (depth >= fade_start)
            ? smoothstep (0.0, 1.0,
                          (depth - fade_start)
                              / (RAYMARCH_MAX_DISTANCE
                                 * (FADE_END_FACTOR - FADE_START_FACTOR)))
            : 0.0;

  final_color = mix (final_color, lighting_ubo.background_color.rgb, fade_t);
  final_color = linear_to_srgb (final_color);

  imageStore (output_image, pixel_coords, vec4 (final_color, 1.0));
}
